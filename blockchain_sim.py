# Blockchain Simulation, written in Python3
# To cut the tedious part of configuring parameters, use indirection : <sample_input

import numpy
import math
import heapq
import os
from decimal import *
import pickle
import random


def get_min_transmission_times(adj_graph):
    nvertices = numpy.shape(adj_graph)[0]
    min_transmission_times = numpy.full((nvertices, nvertices), math.inf)
    for src in range(nvertices):
        visited = [False for x in range(nvertices)]
        min_transmission_times[src][src] = int(0)
        visited[src] = True
        pq = [[0, src]]
        heapq.heapify(pq)
        while pq:
            dist = pq[0][0]
            vert = pq[0][1]
            pq = pq[1:]
            for j in range(nvertices):
                if visited[j] or adj_graph[vert][j] == -1:
                    continue
                if min_transmission_times[src][j] > dist + adj_graph[vert][j]:
                    min_transmission_times[src][j] = dist + adj_graph[vert][j]
                    pq.append([min_transmission_times[src][j], j])
            heapq.heapify(pq)
            visited[vert] = True
    int_min_transmission_times = numpy.zeros((nvertices, nvertices), dtype=int)
    for i in range(nvertices):
        for j in range(nvertices):
            int_min_transmission_times[i][j] = int(min_transmission_times[i][j])
    return int_min_transmission_times


print("---------------------")
print("Blockchain Simulation")
print("---------------------")

# Parameter inputs
print("\nEnter the total number of nodes :")
num_nodes = int(input())

print("\nEnter the total number of miners :")
num_miners = int(input())
num_devices = num_nodes + num_miners

print("\nEnter the {}x{} adjacency matrix for the inter-device communication times in integers that denote simulated seconds. The network is modelled as an undirected weighted graph. The first {} vertices are nodes, and the rest {} are miners. If no edge is present, enter -1.".format(
    num_devices, num_devices, num_nodes, num_miners))
adj_graph = numpy.zeros((num_devices, num_devices), dtype=int)
for i in range(num_devices):
    for j in range(num_devices):
        adj_graph[i][j] = int(input())

nodes_tx_interval = {}
print("\nFor each of the nodes, enter the interval between two transactions, in integers that denote simulated seconds.")
for i in range(num_nodes):
    nodes_tx_interval[i] = int(input())

miners_hashes_per_second = {}
print("\nFor each of the miners, enter the hashes producable per second, in integers that denote simulated seconds.")
for i in range(num_nodes, num_devices):
    miners_hashes_per_second[i] = int(input())

print("\nEnter the target difficulty in a hexadecimal string of length 32. Mining succeeds if hash_generated < target_difficulty.")
target_difficulty = int(input(), 16)

print("\nEnter the time till which simulation is to be run in integer that denotes simulated seconds :")
max_time = int(input())

min_transmission_times = get_min_transmission_times(adj_graph)

# print(adj_graph)
# print(nodes_tx_interval)
# print(miners_hashes_per_second)
# print(min_transmission_times)
# print(max_time)
# exit()

# The fun part begins now

getcontext().prec = 1000
max_difficulty = int("ffffffffffffffffffffffffffffffff", 16) - 1
prob_hash_success = Decimal(target_difficulty) / Decimal(max_difficulty)
# Probability that a miner mines successfully is 1 - P(event that all hashes_per_second tries of the miner failed) => 1-(1-p)^k where k is hashes_per_second, p is prob_hash_success
prob_mining_success = {miner: (1 - ((1 - prob_hash_success) ** miners_hashes_per_second[miner])) for miner in range(num_nodes, num_devices)}

txs_in_transmit = {miner: [] for miner in range(num_nodes, num_devices)}
mining_queue = {miner: [] for miner in range(num_nodes, num_devices)}
mined_transactions = set([])

print("\nStarting simulation..")
time = 0
while time <= max_time:
    print("\nTime = {}".format(time))
    # nodes create tx, miners add tx to tx_queue, miners try mining, if success send them
    # Create transactions and add them on transmission queue
    for node in range(num_nodes):
        if time % nodes_tx_interval[node] == 0:
            print("\nTransaction generated by node {}".format(node))
            for target_node in range(num_nodes, num_devices):
                txs_in_transmit[target_node].append([node, time, time + min_transmission_times[node][target_node]])

    # If the time has come, transfer the transactions from transmission queues to mining queues
    for miner in range(num_nodes, num_devices):
        to_transfer = [tx for tx in txs_in_transmit[miner] if tx[2] == time]
        for tx in list(to_transfer):
            print("\nMiner {} received the transaction {} and queued for mining".format(miner, tx))
            mining_queue[miner].append(tx)
            to_transfer.remove(tx)

    # Mining process. Sadly, the mining doesnt happen parallelly across all miners as it is in real world blockchain. Here, miners are picked in random order to achieve something close to it.
    rand_miners_list = []
    for miner in range(num_nodes, num_devices):
        rand_miners_list.append(miner)
    random.shuffle(rand_miners_list)
    for miner in rand_miners_list:
        if not mining_queue[miner]:
            continue
        print("\nMiner {} attempting to mine block..".format(miner))
        rnd = int.from_bytes(os.urandom(8), byteorder="big") / ((1 << 64) - 1)
        if rnd < prob_mining_success[miner]:
            # Voila, mining is successful. However, a block gets added only if none of the transations contained in it have become part of a previous block.
            # This is an oversimplification of the real scenario where the longest chain always wins, and needs to be improved.
            print("\nMining successful. Attempting to add block..")
            all_txs_are_new = True
            for tx in mining_queue[miner]:
                if pickle.dumps(tx[:2]) in mined_transactions:
                    print("\nMined block is invalid due to the presence of already mined transaction {}. Could not add block.".format(tx[:2]))
                    all_txs_are_new = False
                    break
            if all_txs_are_new:
                print("\nMined block is valid. Block added : {}".format(mining_queue[miner]))
                for tx in mining_queue[miner]:
                    mined_transactions.add(pickle.dumps(tx[:2]))
            mining_queue[miner] = []
        else:
            print("\nMining unsuccessful")

    time += 1
